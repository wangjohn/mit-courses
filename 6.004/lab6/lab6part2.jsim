
*****************************
** PART 1 OF BETA
*****************************

*****
***** PC
*****
.include "nominal.jsim"
.include "stdcell.jsim"
*.include "lab6pc.jsim"

******* adder ******
*nand
.subckt nand2 a b z
MPD1 z a 1 0 NENH sw=2 sl=1
MPD2 1 b 0 0 NENH sw=2 sl=1
MPU1 z a vdd vdd PENH sw=2 sl=1
MPU2 z b vdd vdd PENH sw=2 sl=1
.ends


*nor
.subckt nor2 a b z
MPD1 z a 0 0 NENH sw=2 sl=1
MPD2 z b 0 0 NENH sw=2 sl=1
MPU1 z a 1 vdd PENH sw=2 sl=1
MPU2 1 b vdd vdd PENH sw=2 sl=1
.ends

*xor
.subckt xor2 a b z
Xg0 a b c nor2
MPD1 z a 2 0 NENH sw=2 sl=1
MPD2 2 b 0 0 NENH sw=2 sl=1
MPD3 Z c 0 0 NENH sw=2 sl=1
MPU1 1 a vdd vdd PENH sw=4 sl=1
MPU2 z c 1 vdd PENH sw=4 sl=1
MPU3 1 b vdd vdd PENH sw=4 sl=1
.ends

*3 input nand gate
.subckt nand3 a b c z
MPD1 z a 1 0 NENH sw=2 sl=1
MPD2 1 b 2 0 NENH sw=2 sl=1
MPD3 2 c 0 0 NENH sw=2 sl=1
MPU1 z a vdd vdd PENH sw=2 sl=1
MPU2 z b vdd vdd PENH sw=2 sl=1
MPU3 z c vdd vdd PENH sw=2 sl=1
.ends


*making adder components
*component with output s
.subckt compS a b c s 
Xg0 a b d xor2
Xg1 d c s xor2
.ends

*trial compCo
.subckt compCo a b c z
Xg0 a b x nand2
Xg1 b c y nand2
Xg2 a c w nand2
Xg3 x y w z nand3
.ends

*full-adder stuff here
.subckt FA a b ci s co
Xg0 a b ci s compS
Xg1 a b ci co compCo
.ends

.subckt ADDER4 a3 a2 a1 a0 b3 b2 b1 b0 s4 s3 s2 s1 s0
Xbit0 a0 b0 0 s0 c0 FA
Xbit1 a1 b1 c0 s1 c1 FA
Xbit2 a2 b2 c1 s2 c2 FA
Xbit3 a3 b3 c2 s3 s4 FA
.ends

*32 bit nor gate
.subckt nor32 a[31:0] z
xg0 a[7:0] a[15:8] a[23:16] a[31:24] y[7:0] nor4
Xg1 y[7:6] y[5:4] y[3:2] y[1:0] y[9:8] nand4
Xg2 y[9] y[8] z nor2
.ends


*32 bit negator
.subckt neg32 a[31:0] alufn0 z[31:0]
Xg1 a[31:0] alufn0#32 z[31:0] xor2
.ends 

***** 32 bit adder *****
.subckt adder32 ALUFN[0] A[31:0] B[31:0] S[31:0] z v n
*negation of b
Xnegate B[31:0] ALUFN[0] bx[31:0] neg32
*adder comp
Xfirst A[0] bx[0] ALUFN[0] S[0] co[0] FA
Xbuf1 co[30:0] cin[31:1] buffer
Xadd A[31:1] bx[31:1] cin[31:1] S[31:1] co[31:1] FA 
*z true when S is all zero
Xz0 S[31:0] z nor32
*v true when overflowed
Xinv1 A[31] i1 inverter
Xinv2 bx[31] i2 inverter
Xinv3 S[31] i3 inverter
Xan1 A[31] bx[31] i3 y1 and3
Xan2 i1 i2 S[31] y2 and3
Xr y1 y2 v or2
*n true when S is negative ie S[31] = 1
Xn0 S[31] vdd n and2
.ends

***** pc *****
.subckt pc clk reset ia[31:0]

Xmux_pc reset#32 pcfour[31:0] 0#32 pc[31:0] mux2
Xdreg_pc pc[31:0] clk#32 ia[31:0] dreg

Xc1 c1 constant1 
*CONSTANT4 ****how to do this?! ****
Xc00 c0 constant0
Xadd4_pc c0 ia[31:0] 0#29 c1 0#2 pcfour[31:0] s v n adder32

.ends
*.plot Xpc.pc[31:0]
*.plot Xpc.pcfour[31:0]


***** 
***** REGFILE
*****
*.include "lab6regfile.jsim"

.subckt regfile clk werf ra2sel ra[4:0] rb[4:0] rc[4:0] wdata[31:0] radata[31:0] rbdata[31:0]

***** AND gates to make r31 read 0x0 *****
Xand1 ra[4] ra[3] ra[2] ra[1] za1 and4
Xand2 za1 ra[0] zao and2
Xand3 ra2mux[4] ra2mux[3] ra2mux[2] ra2mux[1] y and4
Xand4 y ra2mux[0] z_ra2mux and2


Xr31a zao#32 adata[31:0] 0#32 radata[31:0] mux2
Xr31ra2 z_ra2mux#32 bdata[31:0] 0#32 rbdata[31:0] mux2


***** ra2sel mux ******
Xra2sel_mux1 ra2sel#5 rb[4:0] rc[4:0] ra2mux[4:0] mux2


Xregfile 
+ vdd 0 0 ra[4:0] adata[31:0] 		//A read port
+ vdd 0 0 ra2mux[4:0] bdata[31:0] 	//B read port
+ 0 clk werf rc[4:0] wdata[31:0] 	//write port
+ $memory width=32 nlocations=31	
+ contents=(0x00000000 0x00000000 0x00000000)

.ends




***** 
***** CTL
*****
*.include "lab6ctl.jsim"

.subckt ctl reset id[31:26] ra2sel bsel alufn[5:0] wdsel[1:0] werf moe wr pcsel[2:0] wasel asel z


Xctl vdd 0 0 id[31:26]	    //one read port
+ xpcsel[2:0] wasel asel ra2sel bsel alufn[5:0] wdsel[1:0] werf moe xwr 
+ $memory width=18 nlocations=64 contents=(
+ 0b011100000000000100		//row1
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100		
+ 0b011100000000000100		//row2
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100		//row3
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b000000100000010110		 //opcode=0b011000, LD
+ 0b000001100000000001		 //opcode=0b011001, ST
+ 0b011100000000000100		 
+ 0b010000000000000100		 //opcode=0b011011, JMP 
+ 0b011100000000000100	
+ 0b000000000000000100		 //opcode=0b011101, BEQ 
+ 0b000000000000000100		 //opcode=0b011110, BNE 
+ 0b000010001101010110		 //opcode=0b011111, LDR,
+ 0b000000000000001100		 //opcode=0b100000, ADD
+ 0b000000000000101100		 //opcode=0b100001, SUB
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b000000011001101100		 //opcode=0b100100, CMPEQ
+ 0b000000011010101100		 //opcode=0b000101, CMPLT
+ 0b000000011011101100		 //opcode=0b000110, CMPLE
+ 0b011100000000000100		 //opcode=0b100111
+ 0b000000001100001100		 //opcode=0b101000, AND
+ 0b000000001111001100		 //opcode=0b101001, OR
+ 0b000000001011001100		 //opcode=0b101010, XOR
+ 0b011100000000000100		 
+ 0b000000010000001100		 //opcode=0b101100, SHL
+ 0b000000010000101100		 //opcode=0b101101, SHR
+ 0b000000010001101100		 //opcode=0b101110, SRA
+ 0b011100000000000100	
+ 0b000000100000001100		 //opcode=0b110000, ADDC
+ 0b000000100000101100		 //opcode=0b110001, SUBC
+ 0b011100000000000100	
+ 0b011100000000000100	
+ 0b000000111001101100		 //opcode=0b110100, CMPEQC
+ 0b000000111010101100		 //opcode=0b110101, CMPLTC
+ 0b000000111011101100		 //opcode=0b110110, CMPLEC
+ 0b011100000000000100	
+ 0b000000101100001100		 //opcode=0b111000, ANDC
+ 0b000000101111001100		 //opcode=0b111001, ORC
+ 0b000000101011001100		 //opcode=0b111010, XORC
+ 0b011100000000000100	
+ 0b000000110000001100		 //opcode=0b111100, SHLC
+ 0b000000110000101100		 //opcode=0b111101, SHRC
+ 0b000000110001101100		 //opcode=0b111110, SRAC
+ 0b011100000000000100	
+)

Xwr_mux reset xwr 0 wr mux2



***** CAN OPTIMIZE *****
Xg0 z zinv inverter
Xg1 id[31] h inverter
Xg2 id[27] m inverter
Xg3 id[26] l inverter
Xg4 h id[30] id[29] a1 and3

***** BEQ logic *****
Xg5 id[28] m id[26] b1 and3
Xg6 a1 b1 z zbeq and3

***** BNE logic *****
Xg7 id[28] id[27] l b2 and3
Xg8 a1 b2 zinv zbne and3

Xg9 zbeq#3 zbne#3 xpcsel[2:0] 0#2 z 0#2 zinv 0#3 pcsel[2:0] mux4

.ends



***** ALU  *****

.subckt compare32 ALUFN[2:1] z v n cmp[31:0]
*higher order ouput bits all zero
Xg0 0#31 cmp[31:1] buffer

*LSB subcomp
Xg1 ALUFN[2:1] inv[2:1] inverter
Xg2 z inv[2] ALUFN[1] i and3
Xg3 n v y xor2
Xg4 y ALUFN[2] inv[1] j and3
Xg5 z y e or2
Xg6 e ALUFN[2] ALUFN[1] k and3
Xg7 i j k cmp[0] or3
.ends

.subckt boole32 ALUFN[3:0] A[31:0] B[31:0] boole[31:0]
Xgand A[31:0] B[31:0] zand[31:0] and2
Xgor A[31:0] B[31:0] zor[31:0] or2
Xgxor A[31:0] B[31:0] zxor[31:0] xor2

Xgmux A[31:0] B[31:0] ALUFN[0]#32 ALUFN[1]#32 ALUFN[2]#32 ALUFN[3]#32 boole[31:0] mux4

.ends

.subckt shift32 ALUFN[1:0] A[31:0] B[4:0] shift[31:0]

*left shifter
Xls16 B[4]#32 A[31:0] A[15:0] 0#16 W[31:0] mux2
Xls8 B[3]#32 W[31:0] W[23:0] 0#8 X[31:0] mux2
Xls4 B[2]#32 X[31:0] X[27:0] 0#4 Y[31:0] mux2
Xls2 B[1]#32 Y[31:0] Y[29:0] 0#2 Z[31:0] mux2
Xls1 B[0]#32 Z[31:0] Z[30:0] 0 SL[31:0] mux2


*choose a[31] or zeros
Xra16 ALUFN[1]#16 0#16 a[31]#16 i[15:0] mux2
Xra8 ALUFN[1]#8 0#8 a[31]#8 j[7:0] mux2
Xra4 ALUFN[1]#4 0#4 a[31]#4 k[3:0] mux2
Xra2 ALUFN[1]#2 0#2 a[31]#2 l[1:0] mux2
Xra1 ALUFN[1] 0 a[31] m mux2

*right shifter
Xrs16 B[4]#32 A[31:0] i[15:0] A[31:16] wr[31:0] mux2
Xrs8 B[3]#32 wr[31:0] j[7:0] wr[31:8] xr[31:0] mux2
Xrs4 B[2]#32 xr[31:0] k[3:0] xr[31:4] yr[31:0] mux2
Xrs2 B[1]#32 yr[31:0] l[1:0] yr[31:2] zr[31:0] mux2
Xrs1 B[0]#32 zr[31:0] m zr[31:1] SR[31:0] mux2

Xs ALUFN[0]#32 SL[31:0] SR[31:0] shift[31:0] mux2
.ends

.subckt alu ALUFN[5:0] A[31:0] B[31:0] alu[31:0] z v n

Xadd ALUFN[0] A[31:0] B[31:0] z_add[31:0] z v n adder32

Xbool ALUFN[3:0] A[31:0] B[31:0] z_bool[31:0] boole32

Xshift ALUFN[1:0] A[31:0] B[4:0] z_shift[31:0] shift32

Xcmp ALUFN[2:1] z v n z_cmp[31:0] compare32

Xm ALUFN[5]#32 ALUFN[4]#32 z_add[31:0] z_shift[31:0] z_bool[31:0] z_cmp[31:0] alu[31:0] mux4

.ends



*****
***** memories and BETA
*****

*.include "lab6basicblock.jsim"
.include "lab6checkoff.jsim"

.subckt beta clk reset irq ia[31:0] id[31:0] ma[31:0] moe mrd[31:0] wr mwd[31:0]

*pc, regfile, ctl



*****
***** step2, A *****
*****
Xpc_beta clk reset pcsel[2:0] jt[31:0] ia[31] br[30:0] ia[31:0] pcf[31:0] pcfive

***** regfile *****
Xregfile_beta clk werf ra2sel id[20:16] id[15:11] wa[4:0] wdata[31:0] radata[31:0] mwd[31:0] regfile


***** bsel mux *****
Xbsel_beta bsel#32 mwd[31:0] id[15]#16 id[15:0] b[31:0] mux2

***** alu *****
Xalu_beta alufn[5:0] adata[31:0] b[31:0] ma[31:0] q v n alu

*****
***** step2 B
*****
***** wasel mux *****
Xwasel_beta wasel#5 id[25:21] vdd#4 0 wa[4:0] mux2

*****
***** step2 C 
***** branch offset
*****
Xbo id[15]#16 id[15:0] so[31:0] buffer
Xbs so[29:0] 0#2 ss[31:0] buffer
Xba_beta 0 pcf[31:0] ss[31:0] br[31:0] i j k adder32

*****
***** step2 D
***** asel mux
*****
Xasel_beta asel#32 radata[31:0] 0 br[30:0] adata[31:0] mux2
* does JT need supervisor bit?????
Xjt_beta radata[31:2] 0#2 jt[31:0] buffer
*Xjt_beta jtz[31:2] 0#2 jt[31:0] buffer

Xnor1 radata[31:24] radata[23:16] radata[15:8] radata[7:0] nor1z[7:0] nor4
Xnor2 nor1z[7:6] nor1z[5:4] nor1z[3:2] nor1z[1:0] nor2z[1:0] nand4
Xnor3 nor2z[1] nor2z[0] z nor2

***** 
***** step2 E
***** wdsel 3input mux
*****
Xwdsel_beta wdsel[0]#32 wdsel[1]#32 ia[31] pcf[30:0] ma[31:0] mrd[31:0] 0#32 wdata[31:0] mux4

*****
***** step2 F
***** control logic
*****
Xctl_beta reset id[31:26] ra2sel bsel alufn[5:0] xwdsel[1:0] xwerf moe xwr xpcsel[2:0] xwasel asel z ctl 

***** IRQ ******
Xnegia31 ia[31] sinv inverter
Xmode irq sinv zmode and2 
Xgwerf zmode xwerf vdd werf mux2
Xgwdsel zmode#2 xwdsel[1:0] 0#2 wdsel[1:0] mux2
Xgwr zmode xwr 0 wr mux2
Xgpcsel zmode#3 xpcsel[2:0] vdd 0#2 pcsel[2:0] mux2
Xgwasel zmode xwasel vdd wasel mux2

.ends


******************************
***** step 2 
******************************

*****
***** A PCfive
*****

.subckt pcfive clk reset pcsel[2:0] jt[31:0] br[31:0] ia[31:0] pcf[31:0]

***** preserve high order bit in jt *****
Xjt_mux ia[31] ia[31] jt[31] j mux2

***** to select pcsel
Xpc1 pcsel[0]#32 pcsel[1]#32 pcf[31:0] br[31:0] j jt[30:0] vdd 0#28 vdd 0#2 pcout[31:0] mux4
Xpc2 pcsel[2]#32 pcout[31:0] vdd 0#27 vdd 0#3 pc[31:0] mux2

***** reset *****
Xreset_pc reset#32 pc[31:0] vdd 0#31 pcz[31:0] mux2

Xdreg_pc pcz[31:0] clk#32 ia[31:0] dreg

Xadd4_pc 0 ia[31:0] 0#29 vdd 0#2 pcf[31:0] s v n adder32

.ends


.plot Xbeta.werf
